package io.h3llo.ecoeats.data.repository

import android.net.Uri
import com.google.android.gms.tasks.Task
import com.google.android.gms.tasks.Tasks
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.storage.FirebaseStorage
import io.h3llo.ecoeats.core.Result
import io.h3llo.ecoeats.domain.model.Recipe
import io.h3llo.ecoeats.domain.repository.RecipeRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.tasks.await
import java.util.UUID
import javax.inject.Inject

class RecipeRepositoryImp @Inject constructor(
    val firebaseFirestore: FirebaseFirestore,
    val firebaseStorage: FirebaseStorage
) : RecipeRepository {
    override suspend fun getRecipes(): Result<List<Recipe>> {

        try {

            val task = firebaseFirestore
                .collection("recipes")
                .get()
            Tasks.await(task)

            if (task.isSuccessful) {
                val newList = task.result?.documents?.mapNotNull { document ->
                    document.toObject(Recipe::class.java)
                }
                return Result.Success(data = newList)
            } else {
                return Result.Error(message = "Error al obtener las recetas")
            }

        } catch (ex: Exception) {
            return Result.Error(message = ex.message)
        }
    }

    override suspend fun getRecipesByTitle(searchValue: String): Flow<Result<List<Recipe>>> = flow {
        try {

            val searchValueUpper = searchValue.uppercase()

            val task = firebaseFirestore
                .collection("recipes")
                .whereGreaterThanOrEqualTo("titleMayus", searchValueUpper)
                .whereLessThanOrEqualTo("titleMayus", searchValueUpper + "\uF8FF")
                .get()
            Tasks.await(task)

            if (task.isSuccessful) {
                val newList = task.result?.documents?.mapNotNull { document ->
                    document.toObject(Recipe::class.java)
                }
                // return Result.Success(data = newList)
                emit(Result.Success(data = newList))
            } else {
                // return Result.Error(message = "Error al obtener las recetas")
                emit(Result.Error(message = "Error al obtener las recetas"))
            }

        } catch (ex: Exception) {
            // return Result.Error(message = ex.message)
            emit(Result.Error(message = ex.message))
        }
    }.flowOn(Dispatchers.IO)

    override suspend fun uploadImageAndSaveRecipe(
        title: String,
        description: String,
        uri: Uri?
    ): Flow<Result<String>> = flow<Result<String>> {

        try {

            val imageName = UUID.randomUUID().toString()

            // UPLOAD IMAGE TO FirebaseStorage
            val imageRef = firebaseStorage.reference.child("recipes/$imageName")
            uri?.let {
                imageRef.putFile(it).await()
            }

            // OBTAIN THE URL OF THE IMAGE
            val imageUrl = imageRef.downloadUrl.await().toString()

            // SAVE THE RECIPE IN FirebaseStorage
            //firebaseFirestore.collection("recipes").document()
            // When You use .add the DB generates its own id. to use a non autogenerated id, you use .document

            val newRecipe = Recipe(
                title = title,
                description = description,
                url = imageUrl,
                titleMayus = title.uppercase()
            )
            firebaseFirestore.collection("recipes").add(newRecipe).await()

            emit(Result.Success(data = "Receta guardada !!"))
        }catch (ex:Exception){
            emit(Result.Error(message = ex.message.toString()))
        }
    }.flowOn(Dispatchers.IO)
}
















